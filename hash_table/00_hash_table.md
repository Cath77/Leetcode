# 哈希表
* 如遇到需要判断一个元素是否出现过的场景，应第一时间想到哈希法！

## [基础理论](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.md)
* 哈希表是根据关键码的值而直接进行访问的数据结构。
    * 数组就是一张哈希表，其关键值是数组下标，通过下标直接访问数组元素。
    * 哈希表的关键码是任意的，可以是整数，也可以是字符串。
* 哈希表可以用来快速判断一个元素是否出现在集合中，即根据给定的key值计算出目标位置的value值。
    * 哈希表的关键码需要转换成整数，然后通过哈希函数计算出目标位置的下标，从而访问元素。-> **哈希函数**
* 常见的哈希结构：数组，集合（set），映射（map）。
    * 数组：数组只能通过下标来访问元素，而哈希表可以通过任意的key值（可以是整数，也可以是字符串）来访问元素。

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| --- | --- | ---- | --- | --- | --- | --- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。  
当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| --- | --- | --- | --- | --- | --- | --- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。



* **哈希函数**：将任意的key值转换成整数的函数
    * 通过hashCode把名字**转化**为数值：通过特定编码方式，可以将其他数据格式转化为哈希表上不同的索引数字。
    * 为了避免转化后得到的索引数字不超出哈希表的索引范围，需要对哈希表的长度**取模**。
    * 当需要转化的数据量很大时，可能会出现不同的数据转化后得到的索引数字相同的情况，这种情况称为**哈希碰撞（哈希冲突）**。
    * 哈希函数的设计原则：哈希函数的设计需要满足以下原则：
        * 一致性：如果a==b，则hash(a)==hash(b)。
        * 高效性：计算高效简便。
        * 均匀性：哈希值均匀分布。

* **哈希碰撞（哈希冲突）**：不同的key值经过哈希函数计算后得到的下标相同
    * 解决方法：拉链法，线性探测法
        * **拉链法**：将冲突的元素以链表的形式储存，然后链接到哈希表的对应位置。
            * 总体数据规模是dataSize， 哈希表的大小为tableSize。
            * 哈希表的查找、插入、删除操作的时间复杂度都是$O(1)$。
            * 哈希表的空间复杂度是$O(n)$，n是哈希表的长度。
        * **线性探测法**：当发生哈希冲突时，线性探测法会将冲突的元素放到下一个空的位置。
            * tableSize一定要大于dataSize ，否则存放时会产生溢出。
            * 哈希表的查找、插入、删除操作的时间复杂度都是$O(1)$。
            * 哈希表的空间复杂度是$O(n)$，n是哈希表的长度。
        


## 242.有效的字母异位词 -> method

### 定义

### 前提

### 注意

### 性能

### 例题
[242.有效的字母异位词](./242_valid-anagram.md)

* **method**  $\sqrt{}$  



## 1002.查找常用字符 -> method

### 定义

### 前提

### 注意

### 性能

### 例题
[1002.查找常用字符](./1002_find-common-characters.md) 

* **method**  $\sqrt{}$  


## 349.两个数组的交集 -> method

### 定义

### 前提

### 注意

### 性能

### 例题
[349.两个数组的交集](./349_intersection-of-two-arrays.md) 

* **method**  $\sqrt{}$  


## 202.快乐数 -> method

### 定义

### 前提

### 注意

### 性能

### 例题
[202.快乐数](./202_happy-number.md) 

* **method**  $\sqrt{}$  


## 1.两数之和 -> method

### 定义

### 前提

### 注意

### 性能

### 例题
[1.两数之和](./1_two-sum.md) 

* **method**  $\sqrt{}$  


## 454.四数相加II -> method

### 定义

### 前提

### 注意

### 性能

### 例题
[454.四数相加II](./454_4sum-ii.md) 

* **method**  $\sqrt{}$ 


## 383.赎金信 -> method

### 定义

### 前提

### 注意

### 性能

### 例题
[383.赎金信](./383_ransom-note.md) 

* **method**  $\sqrt{}$ 


## 15.三数之和 -> method

### 定义

### 前提

### 注意

### 性能

### 例题
[15.三数之和](./15_3sum.md)

* **method**  $\sqrt{}$ 


## 18.四数之和 -> method

### 定义

### 前提

### 注意

### 性能

### 例题
[18.四数之和](./18_4sum.md) 

* **method**  $\sqrt{}$ 



[904_水果成篮（哈希表）](./904_fruit-into-baskets.md)  
[76_最小覆盖子串](./76_minimum-window-substring.md) 


## 总结
![总结](...)