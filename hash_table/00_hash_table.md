# 哈希表
* 如遇到需要判断一个元素是否出现过的场景，应第一时间想到哈希法！

## [基础理论](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.md)
* 哈希表是根据关键码的值而直接进行访问的数据结构。
    * 数组就是一张哈希表，其关键值是数组下标，通过下标直接访问数组元素。
    * 哈希表的关键码是任意的，可以是整数，也可以是字符串。
* 哈希表可以用来快速判断一个元素是否出现在集合中，即根据给定的key值计算出目标位置的value值。
    * 哈希表的关键码需要转换成整数，然后通过哈希函数计算出目标位置的下标，从而访问元素。-> **哈希函数**
* 常见的哈希结构：数组，集合（set），映射（map）。
    * 数组：数组只能通过下标来访问元素，而哈希表可以通过任意的key值（可以是整数，也可以是字符串）来访问元素。

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| --- | --- | ---- | --- | --- | --- | --- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。  
当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| --- | --- | --- | --- | --- | --- | --- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。



* **哈希函数**：将任意的key值转换成整数的函数
    * 通过hashCode把名字**转化**为数值：通过特定编码方式，可以将其他数据格式转化为哈希表上不同的索引数字。
    * 为了避免转化后得到的索引数字不超出哈希表的索引范围，需要对哈希表的长度**取模**。
    * 当需要转化的数据量很大时，可能会出现不同的数据转化后得到的索引数字相同的情况，这种情况称为**哈希碰撞（哈希冲突）**。
    * 哈希函数的设计原则：哈希函数的设计需要满足以下原则：
        * 一致性：如果a==b，则hash(a)==hash(b)。
        * 高效性：计算高效简便。
        * 均匀性：哈希值均匀分布。

* **哈希碰撞（哈希冲突）**：不同的key值经过哈希函数计算后得到的下标相同
    * 解决方法：拉链法，线性探测法
        * **拉链法**：将冲突的元素以链表的形式储存，然后链接到哈希表的对应位置。
            * 总体数据规模是dataSize， 哈希表的大小为tableSize。
            * 哈希表的查找、插入、删除操作的时间复杂度都是$O(1)$。
            * 哈希表的空间复杂度是$O(n)$，n是哈希表的长度。
        * **线性探测法**：当发生哈希冲突时，线性探测法会将冲突的元素放到下一个空的位置。
            * tableSize一定要大于dataSize ，否则存放时会产生溢出。
            * 哈希表的查找、插入、删除操作的时间复杂度都是$O(1)$。
            * 哈希表的空间复杂度是$O(n)$，n是哈希表的长度。
        


## 242.有效的字母异位词 -> 计数法
[242.有效的字母异位词](./242_valid-anagram.md)

* 方法
  * 思路
    * 定义一个数组用来记录字符串里字符出现的次数
    * 把字符映射到数组的索引下标上，即将字符a到字符z的ASCII码转换为数字0到25
    * 先存s后删t，最后统计是否有数值不为0，如果有，则代表两个字符串所含有的字母不相同。
  * 性能
    * 时间复杂度: $O(n)$  
    * 空间复杂度: $O(1)$

[49.字母异位词分组](./49_group-anagrams.md) -> 排序法、计数法



## 1002.查找常用字符 -> 计数法
[1002.查找常用字符](./1002_find-common-characters.md) 

* 方法
  * 思路
    * 使用 min_count 存储每个字符在所有字符串中出现次数的最小值 
    * 依次遍历每一个字符串，并记录每个字符的出现次数：
        * 每遍历一个字符串，就使用word_count统计该字符串中每一个字符出现的次数
        * 每统计完一个字符串，就将min_count与word_count相比较，并取每个字符频率最小值
    * 当遍历完所有字符串后，min_count就存储了每个字符在所有字符串中出现次数的最小值
  * 性能
    * 时间复杂度: $O(n(m+|\Sigma|))$。其中n是字符串的数目，m是字符串的平均长度，$\Sigma$ 为字符集，在本题中字符集为所有小写字母，$\Sigma|=26$
    * 空间复杂度：$O(|\Sigma|)$，这里只计算存储答案之外的空间。我们使用了数组word_count和min_count，它们的长度均为$|\Sigma|$



## 349.两个数组的交集 -> 集合（与哈希表）、排序 + 双指针
[349.两个数组的交集](./349_intersection-of-two-arrays.md) 


* 方法一：集合（与哈希表）
    * 思路
        * 使用两个set，或一个hash与set，求其交集
    * 性能
        * 时间复杂度: $O(m+n)$，其中 m 和 n 分别是两个数组的长度。   
        * 空间复杂度: $O(m+n)$，其中 m 和 n 分别是两个数组的长度。
* 方法二：排序 + 双指针
    * 思路
        * 首先对两个数组进行排序，然后使用两个指针遍历两个数组
        * 初始时，两个指针分别指向两个数组的头部
        * 每次比较两个指针指向的两个数组中的数字
            * 如果两个数字不相等，则将指向较小数字的指针右移一位
            * 如果两个数字相等，将该数字添加到set，并将两个指针都右移一位
            * 当至少有一个指针超出数组范围时，遍历结束
    * 性能
        * 时间复杂度: $O(mlogm+nlogn)$，其中 m 和 n 分别是两个数组的长度。
        * 空间复杂度: $O(logm+logn)$，其中 m 和 n 分别是两个数组的长度。


[350.两个数组的交集II](./350_intersection-of-two-arrays-ii.md) -> 哈希表计数法、排序 + 双指针



## 202.快乐数
[202.快乐数](./202_happy-number.md) 

* 方法
  * 思路
    * 计算sum: 通过反复除10，得到位数与余数，用于计算sum
    * 如果sum为1，则为快乐数
    * 如果sum不为1，查找sum是否存在于set中
      * 如果已存在，代表产生循环，则该数不是快乐数
      * 如果不存在，则将sum加入set，继续循环
  * 性能
    * 时间复杂度: $O(log n)$  
    * 空间复杂度: $O(log n)$


[258.各位相加](./258_add-digits.md)
[263.丑数](./263_ugly-number.md) -> 数学法
[141.环形链表](../linked_list/141_linked_list_cycle.md) -> 新增方法：哈希表




## 1.两数之和 -> method
[1.两数之和](./1_two-sum.md) 

* 方法
  * 思路
    * 
    * 
  * 性能
    * 时间复杂度: $O(n)$  
    * 空间复杂度: $O(1)$


## 454.四数相加II -> method
[454.四数相加II](./454_4sum-ii.md) 

* 方法
  * 思路
    * 
    * 
  * 性能
    * 时间复杂度: $O(n)$  
    * 空间复杂度: $O(1)$


## 383.赎金信 -> method
[383.赎金信](./383_ransom-note.md) 

* 方法
  * 思路
    * 
    * 
  * 性能
    * 时间复杂度: $O(n)$  
    * 空间复杂度: $O(1)$


## 15.三数之和 -> method
[15.三数之和](./15_3sum.md)

* 方法
  * 思路
    * 
    * 
  * 性能
    * 时间复杂度: $O(n)$  
    * 空间复杂度: $O(1)$


## 18.四数之和 -> method
[18.四数之和](./18_4sum.md) 

* 方法
  * 思路
    * 
    * 
  * 性能
    * 时间复杂度: $O(n)$  
    * 空间复杂度: $O(1)$


[904_水果成篮（哈希表）](./904_fruit-into-baskets.md)  
[76_最小覆盖子串](./76_minimum-window-substring.md) 


## 总结
![总结](...)