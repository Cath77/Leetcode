# 链表


## 基础理论
* 链表是一种**通过指针串联**在一起的**线性结构**
* 每一个节点由两部分组成，一个是**数据域**，一个是**指针域**（存放指向下一个节点的指针）
* **头指针**：指向链表中第一个结点（即第一个数据元素的存储映像）的存储位置
* **存储方式**：链表中的节点在内存中不是连续分布的 ，而是**散乱分布**在内存中的某地址上，再通过指针域的**指针链接**各个节点。分配机制取决于操作系统的内存管理。




## 链表类型
* **单链表/线性链表**  
  * 最后一个节点的指针域指向null  
  * **头结点**：可在单链表的第一个结点之前附设一个结点；其数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息。其指针域存放指向第一个结点的指针。
  * 单链表中可以没有头结点，但必须有头指针。如果没有头结点，则头指针指向第一个结点。
* **循环链表**
  * 最后一个节点的指针域指向头结点，整个链表形成一个环
  * 可以用来解决约瑟夫环问题
* **双链表**
    * 每个结点有**两个指针域**，一个指向**直接后继**，一个指向**直接前驱**。
    * 双向链表也可以有循环表
    * 既可以向前查询也可以向后查询




## 链表的定义
* 单链表
```
# Python
class ListNode:
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
```

```
// C++
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```




## 链表的操作
* **删除结点** $O(1)$
    * 删除链表中的某个结点，只需要将其前一个结点的指针域指向其后一个结点即可
    * 删除链表中的第一个结点，只需要将头指针指向第二个结点即可
    * 删除链表中的最后一个结点，只需要将倒数第二个结点的指针域指向null即可
    * 被删除的结点仍然占用内存空间，只是不再被链表涵盖。在C++中可选择手动释放其内存，而Python会自动回收内存。
* **添加结点** $O(1)$
    * 在链表中插入一个结点，只需要将其前一个结点的指针域指向其，再将其指针域指向其后一个结点即可
    * 在链表的头部插入一个结点，只需要将头指针指向其，再将其指针域指向原来的第一个结点即可
    * 在链表的尾部插入一个结点，只需要将倒数第二个结点的指针域指向其，再将其指针域指向null即可
* **查找结点** $O(n)$
    * 要删除/添加链表中的某个结点，需要先找到指向该结点的指针，时间复杂度为$O(n)$
* **链表特性 vs. 数组特性**
    ![性能对比](https://camo.githubusercontent.com/6b19f34264e835fcf98a513e5803652a9f1a2ff9f3a37bb5fc2e00723b55e96f/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230303830363139353230303237362e706e67)




## 203.移除链表元素

### 定义
删除链表中等于给定值 val 的所有节点。   
C++需要从内存中释放被删除节点的内存，而Python不需要。  
提示：  
* 列表中的节点数目在范围 [0, $10^4$] 内
* 1 <= Node.val <= 50
* 0 <= val <= 50


### 例题
[203.移除链表元素](./203_remove_element.md)  
时间复杂度: O(n)  
空间复杂度: O(1)

* 直接使用**原链表**来进行删除操作  
由于移除链表非头结点，需要将其前一个节点的指针指向其后一个节点，而头结点没有前一个结点，因此移除头结点和移除其他节点的操作是不一样的，需要写两端逻辑来应对不同的情况。  
  1. 移除头结点：将头结点向后移动一位
  2. 移除其他节点：将其前一个节点的指针指向其后一个节点  
  3. 释放内存  


* 设置一个**虚拟头结点**来进行删除操作  
以统一逻辑移除所有节点，不需要分情况讨论。  
  1. 设置一个虚拟头结点为新的头结点
  2. 通过修改指针域来移除节点
  3. 释放内存
  4. 返回真正的头结点，而非虚拟头结点：``` return dummyNode->next; ```



[237. 删除链表中的节点](./237_delete-node-in-a-linked-list.md)



## 707.设计链表

### 定义
* 实现 MyLinkedList 类：
  * ```MyLinkedList()```: 初始化 MyLinkedList 对象。
  * ```int get(int index)```：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
  * ```void addAtHead(int val)```：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
  * ```void addAtTail(int val)```：将值为 val 的节点追加到链表的最后一个元素。
  * ```void addAtIndex(int index, int val)```：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。
  * ```void deleteAtIndex(int index)```：如果索引 index 有效，则删除链表中的第 index 个节点。



### 例题
[707.设计链表](./707_Design_Linked_List.md)  
时间复杂度: 涉及 index 的相关操作为 $O(index)$, 其余为 $O(1)$  
空间复杂度: $O(n)$



##  206. 反转链表 
### 定义
* 反转一个单链表
* 如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费
* 其实只需要改变链表的next指针的指向，就可以直接将链表反转 ，而不用重新定义一个新的链表


### 例题
[206. 反转链表](./206_reverse-linked-list.md)

* 头插法（链表只遍历了一次）
  * 性能
    * 时间复杂度: $O(n)$  
    * 空间复杂度: $O(1)$

* 迭代法
  * 性能
    * 时间复杂度: $O(n)$  
    * 空间复杂度: $O(1)$

* 递归法（从前往后或从后往前反转）
  * 性能
    * 时间复杂度: $O(n)$  
    * 空间复杂度: $O(n)$

[92. 反转链表 II](./92_reverse-linked-list-ii.md/)


## 24. 两两交换链表中的节点
[24. 两两交换链表中的节点](./24_swap-nodes-in-pairs.md)

* 模拟法  
  * 思路
    * 使用两个指针来指向需要置换的两个结点。此处类似于头插法，但需要不停更新pre，cur和next的位置。
  * 性能
    * 时间复杂度: $O(n)$  
    * 空间复杂度: $O(1)$

[25. K 个一组翻转链表](./25_reverse-nodes-in-k-group.md)

## 19. 删除链表的倒数第 N 个结点
[19. 删除链表的倒数第 N 个结点](./19_remove-nth-node-from-end-of-list.md)

* 双指针法
  * 思路
    * 如果要删除倒数第n个节点，让fast移动 $n+1$ 步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow的下一个节点即可。
    * 为什么是fast先移动 $n+1$ 步？因为此时fast和slow之间相差 $n+1$ 个节点，当fast指向链表末尾时，slow指向倒数第 $n+1$ 个节点，即需要删除的节点的前一个节点。这样更方便进行删除操作。
  * 性能
    * 时间复杂度: $O(n)$  
    * 空间复杂度: $O(1)$



## 160.链表相交
[160. 链表相交](./160_intersection-of-two-linked-lists.md)
* 滑动指针
  * 思路
    * 求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置.  
    * 比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果相同，则找到交点。
      * 注意：交点不是数值相等，而是指针相等，即curA == curB。
    * 如果遍历到表尾仍未找到焦点，则返回空指针。
  * 性能
    * 时间复杂度: $O(m + n)$，其中m和n分别是两个链表的长度  
    * 空间复杂度: $O(1)$
