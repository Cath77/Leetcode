# 链表


## 基础理论
* 链表是一种**通过指针串联**在一起的**线性结构**
* 每一个节点由两部分组成，一个是**数据域**，一个是**指针域**（存放指向下一个节点的指针）
* **头指针**：指向链表中第一个结点（即第一个数据元素的存储映像）的存储位置
* **存储方式**：链表中的节点在内存中不是连续分布的 ，而是**散乱分布**在内存中的某地址上，再通过指针域的**指针链接**各个节点。分配机制取决于操作系统的内存管理。




## 链表类型
* **单链表/线性链表**  
  * 最后一个节点的指针域指向null  
  * **头结点**：可在单链表的第一个结点之前附设一个结点；其数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息。其指针域存放指向第一个结点的指针。
  * 单链表中可以没有头结点，但必须有头指针。如果没有头结点，则头指针指向第一个结点。
* **循环链表**
  * 最后一个节点的指针域指向头结点，整个链表形成一个环
  * 可以用来解决约瑟夫环问题
* **双链表**
    * 每个结点有**两个指针域**，一个指向**直接后继**，一个指向**直接前驱**。
    * 双向链表也可以有循环表
    * 既可以向前查询也可以向后查询




## 链表的定义
* 单链表
```
# Python
class ListNode:
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
```

```
// C++
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```




## 链表的操作
* **删除结点** $O(1)$
    * 删除链表中的某个结点，只需要将其前一个结点的指针域指向其后一个结点即可
    * 删除链表中的第一个结点，只需要将头指针指向第二个结点即可
    * 删除链表中的最后一个结点，只需要将倒数第二个结点的指针域指向null即可
    * 被删除的结点仍然占用内存空间，只是不再被链表涵盖。在C++中可选择手动释放其内存，而Python会自动回收内存。
* **添加结点** $O(1)$
    * 在链表中插入一个结点，只需要将其前一个结点的指针域指向其，再将其指针域指向其后一个结点即可
    * 在链表的头部插入一个结点，只需要将头指针指向其，再将其指针域指向原来的第一个结点即可
    * 在链表的尾部插入一个结点，只需要将倒数第二个结点的指针域指向其，再将其指针域指向null即可
* **查找结点** $O(n)$
    * 要删除/添加链表中的某个结点，需要先找到指向该结点的指针，时间复杂度为$O(n)$
* **链表特性 vs. 数组特性**
    ![性能对比](https://camo.githubusercontent.com/6b19f34264e835fcf98a513e5803652a9f1a2ff9f3a37bb5fc2e00723b55e96f/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230303830363139353230303237362e706e67)




## 203.移除链表元素

### 定义
删除链表中等于给定值 val 的所有节点。   
C++需要从内存中释放被删除节点的内存，而Python不需要。  
提示：  
* 列表中的节点数目在范围 [0, $10^4$] 内
* 1 <= Node.val <= 50
* 0 <= val <= 50


### 例题
[203.移除链表元素](./203_remove_element.md)  
时间复杂度: O(n)  
空间复杂度: O(1)

* 直接使用**原链表**来进行删除操作  
由于移除链表非头结点，需要将其前一个节点的指针指向其后一个节点，而头结点没有前一个结点，因此移除头结点和移除其他节点的操作是不一样的，需要写两端逻辑来应对不同的情况。  
  1. 移除头结点：将头结点向后移动一位
  2. 移除其他节点：将其前一个节点的指针指向其后一个节点  
  3. 释放内存  


* 设置一个**虚拟头结点**来进行删除操作  
以统一逻辑移除所有节点，不需要分情况讨论。  
  1. 设置一个虚拟头结点为新的头结点
  2. 通过修改指针域来移除节点
  3. 释放内存
  4. 返回真正的头结点，而非虚拟头结点：``` return dummyNode->next; ```



## 707.设计链表

### 定义
* 实现 MyLinkedList 类：
  * ```MyLinkedList()```: 初始化 MyLinkedList 对象。
  * ```int get(int index)```：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
  * ```void addAtHead(int val)```：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
  * ```void addAtTail(int val)```：将值为 val 的节点追加到链表的最后一个元素。
  * ```void addAtIndex(int index, int val)```：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。
  * ```void deleteAtIndex(int index)```：如果索引 index 有效，则删除链表中的第 index 个节点。



### 例题
[707.设计链表](./707_Design_Linked_List.md)  
时间复杂度: 涉及 index 的相关操作为 $O(index)$, 其余为 $O(1)$  
空间复杂度: $O(n)$